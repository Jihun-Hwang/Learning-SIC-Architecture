FIRST	LDA	#STACK	.STACK INIT
	STA	TOP	
	
	JSUB	INLOOP	.TO INPUT LENGTH
	STA	LENGTH
	
	LDX	ZERO
READ	JSUB	INLOOP	.CURRENT INPUT WAS LOADED TO A
	COMP	#0	.if(A == '0')
	JGT	PUSH	.SUM = SUM + A, AND THEN PUSH TO STACK
	JEQ	POP	.POP FROM STACK, AND THEN SUM = SUM - @TOP
BACK	TIX	LENGTH
	JLT	READ
	JSUB	OUTLP

A	J	A

.FOR STACK
PUSH	LDS	SUM
	ADDR	A,S	.S = S + A
	STS	SUM

	STA	@TOP	.(*TOP) = A
	LDA	TOP
	ADD	#3
	STA	TOP
	J	BACK

POP	LDA	TOP
	SUB	#3
	STA	TOP
	LDA	@TOP

	LDS	SUM
	SUBR	A,S	.S = S - A
	STS	SUM
	J	BACK

.FOR INPUT
INLOOP	TD	INDEV
	JEQ	INLOOP
FLUSH	RD	INDEV	.EXECUTED TWICE PER ONE INPUT TO FLUSH NEW LINE

	COMP	NLINE
	JEQ	FLUSH

	SUB	ZEROC
	RSUB

.FOR OUTPUT
OUTLP	TD	OUTDEV
	JEQ	OUTLP
	LDA	SUM

	COMP	#9	.MORE THAN 10, RESULT SHOULD BE PARTITIONED
	JGT	DIVID

	ADD	ZEROC	.ADD 48 TO PRINT CHARACTER
	WD	OUTDEV	
	RSUB

DIVID	DIV	#10
	STA	DIGIT1	.STORE THE FIRST DIGIT

	LDT	SUM
	MUL	#10
	SUBR	A,T	.T = T - A
	STT	DIGIT2	.STORE THE SECOND DIGIT

	LDA	DIGIT1
	ADD	ZEROC
	WD	OUTDEV	.PRINT FIRST PORTION

	LDA	DIGIT2
	ADD	ZEROC
	WD	OUTDEV	.PRINT SECOND PORTION
	RSUB	


TOP	RESW	1	.ADDRESS FOR NEXT TOP OF STACK
STACK	RESW	9	.MAX LEN
LENGTH	RESW	1	.INPUT LENGTH

OUTDEV	BYTE	1
INDEV	BYTE	0

ZEROC	WORD	48	.'0' character (0x30)
NLINE	WORD	10	.NEW LINE character (0x0A)

ZERO	WORD	0
SUM	WORD	0	.RESULT

DIGIT1	RESW	1	.quotient (THE FIRST DIGIT)
DIGIT2	RESW	1	.remainder (THE SECOND DIGIT)